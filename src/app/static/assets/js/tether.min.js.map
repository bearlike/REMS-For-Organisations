{"version":3,"file":"tether.min.js","sources":["../../src/js/utils/type-check.js","../../src/js/utils/classes.js","../../src/js/utils/deferred.js","../../src/js/utils/general.js","../../src/js/utils/bounds.js","../../src/js/abutment.js","../../src/js/constraint.js","../../src/js/shift.js","../../src/js/evented.js","../../src/js/utils/offset.js","../../src/js/utils/parents.js","../../src/js/tether.js"],"sourcesContent":["/**\n * Checks if `value` is classified as a `Function` object.\n * @param {*} value The param to check if it is a function\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `Number` object.\n * @param {*} value The param to check if it is a number\n */\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\n/**\n * Checks if `value` is classified as an `Object`.\n * @param {*} value The param to check if it is an object\n */\nexport function isObject(value) {\n  return typeof value === 'object';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param {*} value The param to check if it is a string\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param {*} value The param to check if it is undefined\n */\nexport function isUndefined(value) {\n  return value === undefined;\n}\n","import { isUndefined } from './type-check';\n\nexport function addClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.add(cls);\n    }\n  });\n}\n\n/**\n * Get class string based on previously determined classes\n * @param  {String} [key=''] - default value for the classes object\n * @param  {Object} classes\n * @param  {String} classPrefix\n */\nexport function getClass(key = '', classes, classPrefix) {\n  if (!isUndefined(classes) && !isUndefined(classes[key])) {\n    if (classes[key] === false) {\n      return '';\n    }\n    return classes[key];\n  } else if (classPrefix) {\n    return `${classPrefix}-${key}`;\n  } else {\n    return key;\n  }\n}\n\nexport function removeClass(el, name) {\n  name.split(' ').forEach((cls) => {\n    if (cls.trim()) {\n      el.classList.remove(cls);\n    }\n  });\n}\n\nexport function updateClasses(el, add, all) {\n  // Of the set of 'all' classes, we need the 'add' classes, and only the\n  // 'add' classes to be set.\n  all.forEach((cls) => {\n    if (add.indexOf(cls) === -1 && el.classList.contains(cls)) {\n      removeClass(el, cls);\n    }\n  });\n\n  add.forEach((cls) => {\n    if (!el.classList.contains(cls)) {\n      addClass(el, cls);\n    }\n  });\n}\n","const deferred = [];\n\nexport function defer(fn) {\n  deferred.push(fn);\n}\n\nexport function flush() {\n  let fn;\n  // eslint-disable-next-line\n  while (fn = deferred.pop()) {\n    fn();\n  }\n}\n","let _scrollBarSize = null;\n\nexport function extend(out = {}) {\n  const args = [];\n\n  Array.prototype.push.apply(args, arguments);\n\n  args.slice(1).forEach((obj) => {\n    if (obj) {\n      for (let key in obj) {\n        if ({}.hasOwnProperty.call(obj, key)) {\n          out[key] = obj[key];\n        }\n      }\n    }\n  });\n\n  return out;\n}\n\nexport function getScrollBarSize() {\n  if (_scrollBarSize) {\n    return _scrollBarSize;\n  }\n  const inner = document.createElement('div');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  extend(outer.style, {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    pointerEvents: 'none',\n    visibility: 'hidden',\n    width: '200px',\n    height: '150px',\n    overflow: 'hidden'\n  });\n\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n\n  const widthContained = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let widthScroll = inner.offsetWidth;\n\n  if (widthContained === widthScroll) {\n    widthScroll = outer.clientWidth;\n  }\n\n  document.body.removeChild(outer);\n\n  const width = widthContained - widthScroll;\n\n  _scrollBarSize = { width, height: width };\n  return _scrollBarSize;\n}\n\nexport const uniqueId = (() => {\n  let id = 0;\n  return () => ++id;\n})();\n","import { defer } from './deferred';\nimport { extend, uniqueId } from './general';\nimport { isUndefined } from './type-check';\n\nconst zeroPosCache = {};\nlet zeroElement = null;\n\nexport function getBounds(body, el) {\n  let doc;\n  if (el === document) {\n    doc = document;\n    el = document.documentElement;\n  } else {\n    doc = el.ownerDocument;\n  }\n\n  const docEl = doc.documentElement;\n\n  const box = _getActualBoundingClientRect(el);\n\n  const origin = _getOrigin(body);\n\n  box.top -= origin.top;\n  box.left -= origin.left;\n\n  if (isUndefined(box.width)) {\n    box.width = document.body.scrollWidth - box.left - box.right;\n  }\n  if (isUndefined(box.height)) {\n    box.height = document.body.scrollHeight - box.top - box.bottom;\n  }\n\n  box.top = box.top - docEl.clientTop;\n  box.left = box.left - docEl.clientLeft;\n  box.right = doc.body.clientWidth - box.width - box.left;\n  box.bottom = doc.body.clientHeight - box.height - box.top;\n\n  return box;\n}\n\n/**\n * Gets bounds for when target modifiier is 'scroll-handle'\n * @param target\n * @return {{left: number, width: number, height: number}}\n */\nexport function getScrollHandleBounds(body, target) {\n  let bounds;\n  // We have to do the check for the scrollTop and if target === document.body here and set to variables\n  // because we may reset target below.\n  const targetScrollTop = target.scrollTop;\n  const targetIsBody = target === document.body;\n\n  if (targetIsBody) {\n    target = document.documentElement;\n\n    bounds = {\n      left: pageXOffset,\n      top: pageYOffset,\n      height: innerHeight,\n      width: innerWidth\n    };\n  } else {\n    bounds = getBounds(body, target);\n  }\n\n  const style = getComputedStyle(target);\n\n  const hasBottomScroll = (\n    target.scrollWidth > target.clientWidth ||\n    [style.overflow, style.overflowX].indexOf('scroll') >= 0 ||\n    !targetIsBody\n  );\n\n  let scrollBottom = 0;\n  if (hasBottomScroll) {\n    scrollBottom = 15;\n  }\n\n  const height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n\n  const out = {\n    width: 15,\n    height: height * 0.975 * (height / target.scrollHeight),\n    left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n  };\n\n  let fitAdj = 0;\n  if (height < 408 && targetIsBody) {\n    fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n  }\n\n  if (!targetIsBody) {\n    out.height = Math.max(out.height, 24);\n  }\n\n  const scrollPercentage = targetScrollTop / (target.scrollHeight - height);\n  out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n\n  if (targetIsBody) {\n    out.height = Math.max(out.height, 24);\n  }\n\n  return out;\n}\n\n/**\n * Gets bounds for when target modifiier is 'visible\n * @param target\n * @return {{top: *, left: *, width: *, height: *}}\n */\nexport function getVisibleBounds(body, target) {\n  if (target === document.body) {\n    return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };\n  } else {\n    const bounds = getBounds(body, target);\n\n    const out = {\n      height: bounds.height,\n      width: bounds.width,\n      top: bounds.top,\n      left: bounds.left\n    };\n\n    out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n    out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));\n    out.height = Math.min(innerHeight, out.height);\n    out.height -= 2;\n\n    out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n    out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));\n    out.width = Math.min(innerWidth, out.width);\n    out.width -= 2;\n\n    if (out.top < pageYOffset) {\n      out.top = pageYOffset;\n    }\n    if (out.left < pageXOffset) {\n      out.left = pageXOffset;\n    }\n\n    return out;\n  }\n}\n\nexport function removeUtilElements(body) {\n  if (zeroElement) {\n    body.removeChild(zeroElement);\n  }\n  zeroElement = null;\n}\n\n/**\n * Same as native getBoundingClientRect, except it takes into account parent <frame> offsets\n * if the element lies within a nested document (<frame> or <iframe>-like).\n * @param node\n */\nfunction _getActualBoundingClientRect(node) {\n  let boundingRect = node.getBoundingClientRect();\n\n  // The original object returned by getBoundingClientRect is immutable, so we clone it\n  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9\n  let rect = {};\n  for (let k in boundingRect) {\n    rect[k] = boundingRect[k];\n  }\n\n  try {\n    if (node.ownerDocument !== document) {\n      let { frameElement } = node.ownerDocument.defaultView;\n      if (frameElement) {\n        let frameRect = _getActualBoundingClientRect(frameElement);\n        rect.top += frameRect.top;\n        rect.bottom += frameRect.top;\n        rect.left += frameRect.left;\n        rect.right += frameRect.left;\n      }\n    }\n  } catch(err) {\n    // Ignore \"Access is denied\" in IE11/Edge\n  }\n\n  return rect;\n}\n\nfunction _getOrigin(body) {\n  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of\n  // jitter as the user scrolls that messes with our ability to detect if two positions\n  // are equivilant or not.  We place an element at the top left of the page that will\n  // get the same jitter, so we can cancel the two out.\n  let node = zeroElement;\n  if (!node || !body.contains(node)) {\n    node = document.createElement('div');\n    node.setAttribute('data-tether-id', uniqueId());\n    extend(node.style, {\n      top: 0,\n      left: 0,\n      position: 'absolute'\n    });\n\n    body.appendChild(node);\n\n    zeroElement = node;\n  }\n\n  const id = node.getAttribute('data-tether-id');\n  if (isUndefined(zeroPosCache[id])) {\n    zeroPosCache[id] = _getActualBoundingClientRect(node);\n\n    // Clear the cache when this position call is done\n    defer(() => {\n      delete zeroPosCache[id];\n    });\n  }\n\n  return zeroPosCache[id];\n}\n","import { getClass, updateClasses } from './utils/classes';\nimport { defer } from './utils/deferred';\nimport { getBounds } from './utils/bounds';\n\nexport default {\n  position({ top, left }) {\n    const { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.element);\n    });\n\n    const targetPos = this.getTargetBounds();\n\n    const bottom = top + height;\n    const right = left + width;\n\n    const abutted = [];\n    if (top <= targetPos.bottom && bottom >= targetPos.top) {\n      ['left', 'right'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === left || targetPosSide === right) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    if (left <= targetPos.right && right >= targetPos.left) {\n      ['top', 'bottom'].forEach((side) => {\n        const targetPosSide = targetPos[side];\n        if (targetPosSide === top || targetPosSide === bottom) {\n          abutted.push(side);\n        }\n      });\n    }\n\n    const sides = ['left', 'top', 'right', 'bottom'];\n    const { classes, classPrefix } = this.options;\n    this.all.push(getClass('abutted', classes, classPrefix));\n    sides.forEach((side) => {\n      this.all.push(`${getClass('abutted', classes, classPrefix)}-${side}`);\n    });\n\n    if (abutted.length) {\n      this.add.push(getClass('abutted', classes, classPrefix));\n    }\n\n    abutted.forEach((side) => {\n      this.add.push(`${getClass('abutted', classes, classPrefix)}-${side}`);\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this.add, this.all);\n      }\n      updateClasses(this.element, this.add, this.all);\n    });\n\n    return true;\n  }\n};\n","import { getClass, updateClasses } from './utils/classes';\nimport { defer } from './utils/deferred';\nimport { extend } from './utils/general';\nimport { getBounds } from './utils/bounds';\nimport { isString, isUndefined } from './utils/type-check';\n\nconst BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\n/**\n * Returns an array of bounds of the format [left, top, right, bottom]\n * @param tether\n * @param to\n * @return {*[]|HTMLElement|ActiveX.IXMLDOMElement}\n */\nfunction getBoundingRect(body, tether, to) {\n  // arg to is required\n  if (!to) {\n    return null;\n  }\n  if (to === 'scrollParent') {\n    to = tether.scrollParents[0];\n  } else if (to === 'window') {\n    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n  }\n\n  if (to === document) {\n    to = to.documentElement;\n  }\n\n  if (!isUndefined(to.nodeType)) {\n    const node = to;\n    const size = getBounds(body, to);\n    const pos = size;\n    const style = getComputedStyle(to);\n\n    to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n\n    // Account any parent Frames scroll offset\n    if (node.ownerDocument !== document) {\n      let win = node.ownerDocument.defaultView;\n      to[0] += win.pageXOffset;\n      to[1] += win.pageYOffset;\n      to[2] += win.pageXOffset;\n      to[3] += win.pageYOffset;\n    }\n\n    BOUNDS_FORMAT.forEach((side, i) => {\n      side = side[0].toUpperCase() + side.substr(1);\n      if (side === 'Top' || side === 'Left') {\n        to[i] += parseFloat(style[`border${side}Width`]);\n      } else {\n        to[i] -= parseFloat(style[`border${side}Width`]);\n      }\n    });\n  }\n\n  return to;\n}\n\n/**\n * Add out of bounds classes to the list of classes we add to tether\n * @param {string[]} oob An array of directions that are out of bounds\n * @param {string[]} addClasses The array of classes to add to Tether\n * @param {string[]} classes The array of class types for Tether\n * @param {string} classPrefix The prefix to add to the front of the class\n * @param {string} outOfBoundsClass The class to apply when out of bounds\n * @private\n */\nfunction _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, outOfBoundsClass) {\n  if (oob.length) {\n    let oobClass;\n    if (!isUndefined(outOfBoundsClass)) {\n      oobClass = outOfBoundsClass;\n    } else {\n      oobClass = getClass('out-of-bounds', classes, classPrefix);\n    }\n\n    addClasses.push(oobClass);\n    oob.forEach((side) => {\n      addClasses.push(`${oobClass}-${side}`);\n    });\n  }\n}\n\n/**\n * Calculates if out of bounds or pinned in the X direction.\n *\n * @param {number} left\n * @param {number[]} bounds Array of bounds of the format [left, top, right, bottom]\n * @param {number} width\n * @param pin\n * @param pinned\n * @param {string[]} oob\n * @return {number}\n * @private\n */\nfunction _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob) {\n  if (left < bounds[0]) {\n    if (pin.indexOf('left') >= 0) {\n      left = bounds[0];\n      pinned.push('left');\n    } else {\n      oob.push('left');\n    }\n  }\n\n  if (left + width > bounds[2]) {\n    if (pin.indexOf('right') >= 0) {\n      left = bounds[2] - width;\n      pinned.push('right');\n    } else {\n      oob.push('right');\n    }\n  }\n\n  return left;\n}\n\n/**\n * Calculates if out of bounds or pinned in the Y direction.\n *\n * @param {number} top\n * @param {number[]} bounds Array of bounds of the format [left, top, right, bottom]\n * @param {number} height\n * @param pin\n * @param {string[]} pinned\n * @param {string[]} oob\n * @return {number}\n * @private\n */\nfunction _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob) {\n  if (top < bounds[1]) {\n    if (pin.indexOf('top') >= 0) {\n      top = bounds[1];\n      pinned.push('top');\n    } else {\n      oob.push('top');\n    }\n  }\n\n  if (top + height > bounds[3]) {\n    if (pin.indexOf('bottom') >= 0) {\n      top = bounds[3] - height;\n      pinned.push('bottom');\n    } else {\n      oob.push('bottom');\n    }\n  }\n\n  return top;\n}\n\n/**\n * Flip X \"together\"\n * @param {object} tAttachment The target attachment\n * @param {object} eAttachment The element attachment\n * @param {number[]} bounds Array of bounds of the format [left, top, right, bottom]\n * @param {number} width\n * @param targetWidth\n * @param {number} left\n * @private\n */\nfunction _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left) {\n  if (left < bounds[0] && tAttachment.left === 'left') {\n    if (eAttachment.left === 'right') {\n      left += targetWidth;\n      tAttachment.left = 'right';\n\n      left += width;\n      eAttachment.left = 'left';\n\n    } else if (eAttachment.left === 'left') {\n      left += targetWidth;\n      tAttachment.left = 'right';\n\n      left -= width;\n      eAttachment.left = 'right';\n    }\n\n  } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n    if (eAttachment.left === 'left') {\n      left -= targetWidth;\n      tAttachment.left = 'left';\n\n      left -= width;\n      eAttachment.left = 'right';\n\n    } else if (eAttachment.left === 'right') {\n      left -= targetWidth;\n      tAttachment.left = 'left';\n\n      left += width;\n      eAttachment.left = 'left';\n    }\n\n  } else if (tAttachment.left === 'center') {\n    if (left + width > bounds[2] && eAttachment.left === 'left') {\n      left -= width;\n      eAttachment.left = 'right';\n\n    } else if (left < bounds[0] && eAttachment.left === 'right') {\n      left += width;\n      eAttachment.left = 'left';\n    }\n  }\n\n  return left;\n}\n\n/**\n * Flip Y \"together\"\n * @param {object} tAttachment The target attachment\n * @param {object} eAttachment The element attachment\n * @param {number[]} bounds Array of bounds of the format [left, top, right, bottom]\n * @param {number} height\n * @param targetHeight\n * @param {number} top\n * @private\n */\nfunction _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top) {\n  if (tAttachment.top === 'top') {\n    if (eAttachment.top === 'bottom' && top < bounds[1]) {\n      top += targetHeight;\n      tAttachment.top = 'bottom';\n\n      top += height;\n      eAttachment.top = 'top';\n\n    } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {\n      top -= height - targetHeight;\n      tAttachment.top = 'bottom';\n\n      eAttachment.top = 'bottom';\n    }\n  }\n\n  if (tAttachment.top === 'bottom') {\n    if (eAttachment.top === 'top' && top + height > bounds[3]) {\n      top -= targetHeight;\n      tAttachment.top = 'top';\n\n      top -= height;\n      eAttachment.top = 'bottom';\n\n    } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {\n      top += height - targetHeight;\n      tAttachment.top = 'top';\n\n      eAttachment.top = 'top';\n\n    }\n  }\n\n  if (tAttachment.top === 'middle') {\n    if (top + height > bounds[3] && eAttachment.top === 'top') {\n      top -= height;\n      eAttachment.top = 'bottom';\n\n    } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n      top += height;\n      eAttachment.top = 'top';\n    }\n  }\n\n  return top;\n}\n\n/**\n * Get all the initial classes\n * @param classes\n * @param {string} classPrefix\n * @param constraints\n * @return {[*, *]}\n * @private\n */\nfunction _getAllClasses(classes, classPrefix, constraints) {\n  const allClasses = [getClass('pinned', classes, classPrefix), getClass('out-of-bounds', classes, classPrefix)];\n\n  constraints.forEach((constraint) => {\n    const { outOfBoundsClass, pinnedClass } = constraint;\n    if (outOfBoundsClass) {\n      allClasses.push(outOfBoundsClass);\n    }\n    if (pinnedClass) {\n      allClasses.push(pinnedClass);\n    }\n  });\n\n  allClasses.forEach((cls) => {\n    ['left', 'top', 'right', 'bottom'].forEach((side) => {\n      allClasses.push(`${cls}-${side}`);\n    });\n  });\n\n  return allClasses;\n}\n\nexport default {\n  position({ top, left, targetAttachment }) {\n    if (!this.options.constraints) {\n      return true;\n    }\n\n    let { height, width } = this.cache('element-bounds', () => {\n      return getBounds(this.bodyElement, this.element);\n    });\n\n    if (width === 0 && height === 0 && !isUndefined(this.lastSize)) {\n      // Handle the item getting hidden as a result of our positioning without glitching\n      // the classes in and out\n      ({ width, height } = this.lastSize);\n    }\n\n    const targetSize = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n\n    const { height: targetHeight, width: targetWidth } = targetSize;\n    const { classes, classPrefix } = this.options;\n\n    const allClasses = _getAllClasses(classes, classPrefix, this.options.constraints);\n    const addClasses = [];\n\n    const tAttachment = extend({}, targetAttachment);\n    const eAttachment = extend({}, this.attachment);\n\n    this.options.constraints.forEach((constraint) => {\n      let { to, attachment, pin } = constraint;\n\n      if (isUndefined(attachment)) {\n        attachment = '';\n      }\n\n      let changeAttachX, changeAttachY;\n      if (attachment.indexOf(' ') >= 0) {\n        [changeAttachY, changeAttachX] = attachment.split(' ');\n      } else {\n        changeAttachX = changeAttachY = attachment;\n      }\n\n      const bounds = getBoundingRect(this.bodyElement, this, to);\n\n      if (changeAttachY === 'target' || changeAttachY === 'both') {\n        if (top < bounds[1] && tAttachment.top === 'top') {\n          top += targetHeight;\n          tAttachment.top = 'bottom';\n        }\n\n        if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n          top -= targetHeight;\n          tAttachment.top = 'top';\n        }\n      }\n\n      if (changeAttachY === 'together') {\n        top = _flipYTogether(tAttachment, eAttachment, bounds, height, targetHeight, top);\n      }\n\n      if (changeAttachX === 'target' || changeAttachX === 'both') {\n        if (left < bounds[0] && tAttachment.left === 'left') {\n          left += targetWidth;\n          tAttachment.left = 'right';\n        }\n\n        if (left + width > bounds[2] && tAttachment.left === 'right') {\n          left -= targetWidth;\n          tAttachment.left = 'left';\n        }\n      }\n\n      if (changeAttachX === 'together') {\n        left = _flipXTogether(tAttachment, eAttachment, bounds, width, targetWidth, left);\n      }\n\n      if (changeAttachY === 'element' || changeAttachY === 'both') {\n        if (top < bounds[1] && eAttachment.top === 'bottom') {\n          top += height;\n          eAttachment.top = 'top';\n        }\n\n        if (top + height > bounds[3] && eAttachment.top === 'top') {\n          top -= height;\n          eAttachment.top = 'bottom';\n        }\n      }\n\n      if (changeAttachX === 'element' || changeAttachX === 'both') {\n        if (left < bounds[0]) {\n          if (eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          } else if (eAttachment.left === 'center') {\n            left += (width / 2);\n            eAttachment.left = 'left';\n          }\n        }\n\n        if (left + width > bounds[2]) {\n          if (eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n          } else if (eAttachment.left === 'center') {\n            left -= (width / 2);\n            eAttachment.left = 'right';\n          }\n        }\n      }\n\n      if (isString(pin)) {\n        pin = pin.split(',').map((p) => p.trim());\n      } else if (pin === true) {\n        pin = ['top', 'left', 'right', 'bottom'];\n      }\n\n      pin = pin || [];\n\n      const pinned = [];\n      const oob = [];\n\n      left = _calculateOOBAndPinnedLeft(left, bounds, width, pin, pinned, oob);\n      top = _calculateOOBAndPinnedTop(top, bounds, height, pin, pinned, oob);\n\n      if (pinned.length) {\n        let pinnedClass;\n        if (!isUndefined(this.options.pinnedClass)) {\n          pinnedClass = this.options.pinnedClass;\n        } else {\n          pinnedClass = getClass('pinned', classes, classPrefix);\n        }\n\n        addClasses.push(pinnedClass);\n        pinned.forEach((side) => {\n          addClasses.push(`${pinnedClass}-${side}`);\n        });\n      }\n\n      _addOutOfBoundsClass(oob, addClasses, classes, classPrefix, this.options.outOfBoundsClass);\n\n      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {\n        eAttachment.left = tAttachment.left = false;\n      }\n      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {\n        eAttachment.top = tAttachment.top = false;\n      }\n\n      if (tAttachment.top !== targetAttachment.top ||\n        tAttachment.left !== targetAttachment.left ||\n        eAttachment.top !== this.attachment.top ||\n        eAttachment.left !== this.attachment.left) {\n        this.updateAttachClasses(eAttachment, tAttachment);\n        this.trigger('update', {\n          attachment: eAttachment,\n          targetAttachment: tAttachment\n        });\n      }\n    });\n\n    defer(() => {\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, addClasses, allClasses);\n      }\n      updateClasses(this.element, addClasses, allClasses);\n    });\n\n    return { top, left };\n  }\n};\n","import { isFunction, isString } from './utils/type-check';\n\nexport default {\n  position({ top, left }) {\n    if (!this.options.shift) {\n      return;\n    }\n\n    let { shift } = this.options;\n    if (isFunction(shift)) {\n      shift = shift.call(this, { top, left });\n    }\n\n    let shiftTop, shiftLeft;\n    if (isString(shift)) {\n      shift = shift.split(' ');\n      shift[1] = shift[1] || shift[0];\n\n      ([shiftTop, shiftLeft] = shift);\n\n      shiftTop = parseFloat(shiftTop, 10);\n      shiftLeft = parseFloat(shiftLeft, 10);\n    } else {\n      ([shiftTop, shiftLeft] = [shift.top, shift.left]);\n    }\n\n    top += shiftTop;\n    left += shiftLeft;\n\n    return { top, left };\n  }\n};\n","import { isUndefined } from './utils/type-check';\n\nexport class Evented {\n  on(event, handler, ctx, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (isUndefined(this.bindings) ||\n      isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      this.bindings[event].forEach((binding, index) => {\n        if (binding.handler === handler) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      this.bindings[event].forEach((binding, index) => {\n        const { ctx, handler, once } = binding;\n\n        const context = ctx || this;\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n","import { isString, isUndefined } from './type-check';\n\nconst MIRROR_LR = {\n  center: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nconst MIRROR_TB = {\n  middle: 'middle',\n  top: 'bottom',\n  bottom: 'top'\n};\n\nconst OFFSET_MAP = {\n  top: 0,\n  left: 0,\n  middle: '50%',\n  center: '50%',\n  bottom: '100%',\n  right: '100%'\n};\n\nexport function addOffset(...offsets) {\n  const out = { top: 0, left: 0 };\n\n  offsets.forEach(({ top, left }) => {\n    if (isString(top)) {\n      top = parseFloat(top);\n    }\n    if (isString(left)) {\n      left = parseFloat(left);\n    }\n\n    out.top += top;\n    out.left += left;\n  });\n\n  return out;\n}\n\nexport function attachmentToOffset(attachment) {\n  let { left, top } = attachment;\n\n  if (!isUndefined(OFFSET_MAP[attachment.left])) {\n    left = OFFSET_MAP[attachment.left];\n  }\n\n  if (!isUndefined(OFFSET_MAP[attachment.top])) {\n    top = OFFSET_MAP[attachment.top];\n  }\n\n  return { left, top };\n}\n\nexport function autoToFixedAttachment(attachment, relativeToAttachment) {\n  let { left, top } = attachment;\n\n  if (left === 'auto') {\n    left = MIRROR_LR[relativeToAttachment.left];\n  }\n\n  if (top === 'auto') {\n    top = MIRROR_TB[relativeToAttachment.top];\n  }\n\n  return { left, top };\n}\n\nexport function offsetToPx(offset, size) {\n  if (isString(offset.left) && offset.left.indexOf('%') !== -1) {\n    offset.left = parseFloat(offset.left) / 100 * size.width;\n  }\n  if (isString(offset.top) && offset.top.indexOf('%') !== -1) {\n    offset.top = parseFloat(offset.top) / 100 * size.height;\n  }\n\n  return offset;\n}\n\nexport function parseTopLeft(value) {\n  const [top, left] = value.split(' ');\n  return { top, left };\n}\n","import { isUndefined } from './type-check';\n\nexport function getScrollParents(el) {\n  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  const computedStyle = getComputedStyle(el) || {};\n  const { position } = computedStyle;\n  let parents = [];\n\n  if (position === 'fixed') {\n    return [el];\n  }\n\n  let parent = el;\n  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {\n    let style;\n    try {\n      style = getComputedStyle(parent);\n    } catch(err) {\n      // Intentionally blank\n    }\n\n    if (isUndefined(style) || style === null) {\n      parents.push(parent);\n      return parents;\n    }\n\n    const { overflow, overflowX, overflowY } = style;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {\n        parents.push(parent);\n      }\n    }\n  }\n\n  parents.push(el.ownerDocument.body);\n\n  // If the node is within a frame, account for the parent window scroll\n  if (el.ownerDocument !== document) {\n    parents.push(el.ownerDocument.defaultView);\n  }\n\n  return parents;\n}\n\nexport function getOffsetParent(el) {\n  return el.offsetParent || document.documentElement;\n}\n","import '../css/tether.scss';\nimport '../css/tether-theme-arrows.scss';\nimport '../css/tether-theme-arrows-dark.scss';\nimport '../css/tether-theme-basic.scss';\nimport Abutment from './abutment';\nimport Constraint from './constraint';\nimport Shift from './shift';\nimport { Evented } from './evented';\nimport { addClass, getClass, removeClass, updateClasses } from './utils/classes';\nimport { defer, flush } from './utils/deferred';\nimport { extend, getScrollBarSize } from './utils/general';\nimport { addOffset, attachmentToOffset, autoToFixedAttachment, offsetToPx, parseTopLeft } from './utils/offset';\nimport { getBounds, getScrollHandleBounds, getVisibleBounds, removeUtilElements } from './utils/bounds';\nimport { getOffsetParent, getScrollParents } from './utils/parents';\nimport { isNumber, isObject, isString, isUndefined } from './utils/type-check';\n\nconst TetherBase = { modules: [Constraint, Abutment, Shift] };\n\nfunction isFullscreenElement(e) {\n  let d = e.ownerDocument;\n  let fe = d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement || d.msFullscreenElement;\n  return fe === e;\n}\n\nfunction within(a, b, diff = 1) {\n  return (a + diff >= b && b >= a - diff);\n}\n\nconst transformKey = (() => {\n  if (isUndefined(document)) {\n    return '';\n  }\n  const el = document.createElement('div');\n\n  const transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n  for (let i = 0; i < transforms.length; ++i) {\n    const key = transforms[i];\n    if (el.style[key] !== undefined) {\n      return key;\n    }\n  }\n})();\n\nconst tethers = [];\n\nconst position = () => {\n  tethers.forEach((tether) => {\n    tether.position(false);\n  });\n  flush();\n};\n\nfunction now() {\n  return performance.now();\n}\n\n(() => {\n  let lastCall = null;\n  let lastDuration = null;\n  let pendingTimeout = null;\n\n  const tick = () => {\n    if (!isUndefined(lastDuration) && lastDuration > 16) {\n      // We voluntarily throttle ourselves if we can't manage 60fps\n      lastDuration = Math.min(lastDuration - 16, 250);\n\n      // Just in case this is the last event, remember to position just once more\n      pendingTimeout = setTimeout(tick, 250);\n      return;\n    }\n\n    if (!isUndefined(lastCall) && (now() - lastCall) < 10) {\n      // Some browsers call events a little too frequently, refuse to run more than is reasonable\n      return;\n    }\n\n    if (pendingTimeout != null) {\n      clearTimeout(pendingTimeout);\n      pendingTimeout = null;\n    }\n\n    lastCall = now();\n    position();\n    lastDuration = now() - lastCall;\n  };\n\n  if (!isUndefined(window) && !isUndefined(window.addEventListener)) {\n    ['resize', 'scroll', 'touchmove'].forEach((event) => {\n      window.addEventListener(event, tick);\n    });\n  }\n})();\n\nclass TetherClass extends Evented {\n  constructor(options) {\n    super();\n    this.position = this.position.bind(this);\n\n    tethers.push(this);\n\n    this.history = [];\n\n    this.setOptions(options, false);\n\n    TetherBase.modules.forEach((module) => {\n      if (!isUndefined(module.initialize)) {\n        module.initialize.call(this);\n      }\n    });\n\n    this.position();\n  }\n\n  setOptions(options, pos = true) {\n    const defaults = {\n      offset: '0 0',\n      targetOffset: '0 0',\n      targetAttachment: 'auto auto',\n      classPrefix: 'tether',\n      bodyElement: document.body\n    };\n\n    this.options = extend(defaults, options);\n\n    let { element, target, targetModifier, bodyElement } = this.options;\n    this.element = element;\n    this.target = target;\n    this.targetModifier = targetModifier;\n\n    if (typeof bodyElement === 'string') {\n      bodyElement = document.querySelector(bodyElement);\n    }\n    this.bodyElement = bodyElement;\n\n    if (this.target === 'viewport') {\n      this.target = document.body;\n      this.targetModifier = 'visible';\n    } else if (this.target === 'scroll-handle') {\n      this.target = document.body;\n      this.targetModifier = 'scroll-handle';\n    }\n\n    ['element', 'target'].forEach((key) => {\n      if (isUndefined(this[key])) {\n        throw new Error('Tether Error: Both element and target must be defined');\n      }\n\n      if (!isUndefined(this[key].jquery)) {\n        this[key] = this[key][0];\n      } else if (isString(this[key])) {\n        this[key] = document.querySelector(this[key]);\n      }\n    });\n\n    this._addClasses();\n\n    if (!this.options.attachment) {\n      throw new Error('Tether Error: You must provide an attachment');\n    }\n\n    this.targetAttachment = parseTopLeft(this.options.targetAttachment);\n    this.attachment = parseTopLeft(this.options.attachment);\n    this.offset = parseTopLeft(this.options.offset);\n    this.targetOffset = parseTopLeft(this.options.targetOffset);\n\n    if (!isUndefined(this.scrollParents)) {\n      this.disable();\n    }\n\n    if (this.targetModifier === 'scroll-handle') {\n      this.scrollParents = [this.target];\n    } else {\n      this.scrollParents = getScrollParents(this.target);\n    }\n\n    if (!(this.options.enabled === false)) {\n      this.enable(pos);\n    }\n  }\n\n  getTargetBounds() {\n    if (!isUndefined(this.targetModifier)) {\n      if (this.targetModifier === 'visible') {\n        return getVisibleBounds(this.bodyElement, this.target);\n      } else if (this.targetModifier === 'scroll-handle') {\n        return getScrollHandleBounds(this.bodyElement, this.target);\n      }\n    } else {\n      return getBounds(this.bodyElement, this.target);\n    }\n  }\n\n  clearCache() {\n    this._cache = {};\n  }\n\n  cache(k, getter) {\n    // More than one module will often need the same DOM info, so\n    // we keep a cache which is cleared on each position call\n    if (isUndefined(this._cache)) {\n      this._cache = {};\n    }\n\n    if (isUndefined(this._cache[k])) {\n      this._cache[k] = getter.call(this);\n    }\n\n    return this._cache[k];\n  }\n\n  enable(pos = true) {\n    const { classes, classPrefix } = this.options;\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, getClass('enabled', classes, classPrefix));\n    }\n    addClass(this.element, getClass('enabled', classes, classPrefix));\n    this.enabled = true;\n\n    this.scrollParents.forEach((parent) => {\n      if (parent !== this.target.ownerDocument) {\n        parent.addEventListener('scroll', this.position);\n      }\n    });\n\n    if (pos) {\n      this.position();\n    }\n  }\n\n  disable() {\n    const { classes, classPrefix } = this.options;\n    removeClass(this.target, getClass('enabled', classes, classPrefix));\n    removeClass(this.element, getClass('enabled', classes, classPrefix));\n    this.enabled = false;\n\n    if (!isUndefined(this.scrollParents)) {\n      this.scrollParents.forEach((parent) => {\n        parent.removeEventListener('scroll', this.position);\n      });\n    }\n  }\n\n  destroy() {\n    this.disable();\n\n    this._removeClasses();\n\n    tethers.forEach((tether, i) => {\n      if (tether === this) {\n        tethers.splice(i, 1);\n      }\n    });\n\n    // Remove any elements we were using for convenience from the DOM\n    if (tethers.length === 0) {\n      removeUtilElements(this.bodyElement);\n    }\n  }\n\n  updateAttachClasses(elementAttach, targetAttach) {\n    elementAttach = elementAttach || this.attachment;\n    targetAttach = targetAttach || this.targetAttachment;\n    const sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n    const { classes, classPrefix } = this.options;\n\n    if (!isUndefined(this._addAttachClasses) && this._addAttachClasses.length) {\n      // updateAttachClasses can be called more than once in a position call, so\n      // we need to clean up after ourselves such that when the last defer gets\n      // ran it doesn't add any extra classes from previous calls.\n      this._addAttachClasses.splice(0, this._addAttachClasses.length);\n    }\n\n    if (isUndefined(this._addAttachClasses)) {\n      this._addAttachClasses = [];\n    }\n    this.add = this._addAttachClasses;\n\n    if (elementAttach.top) {\n      this.add.push(`${getClass('element-attached', classes, classPrefix)}-${elementAttach.top}`);\n    }\n    if (elementAttach.left) {\n      this.add.push(`${getClass('element-attached', classes, classPrefix)}-${elementAttach.left}`);\n    }\n    if (targetAttach.top) {\n      this.add.push(`${getClass('target-attached', classes, classPrefix)}-${targetAttach.top}`);\n    }\n    if (targetAttach.left) {\n      this.add.push(`${getClass('target-attached', classes, classPrefix)}-${targetAttach.left}`);\n    }\n\n    this.all = [];\n    sides.forEach((side) => {\n      this.all.push(`${getClass('element-attached', classes, classPrefix)}-${side}`);\n      this.all.push(`${getClass('target-attached', classes, classPrefix)}-${side}`);\n    });\n\n    defer(() => {\n      if (isUndefined(this._addAttachClasses)) {\n        return;\n      }\n\n      updateClasses(this.element, this._addAttachClasses, this.all);\n      if (!(this.options.addTargetClasses === false)) {\n        updateClasses(this.target, this._addAttachClasses, this.all);\n      }\n\n      delete this._addAttachClasses;\n    });\n  }\n\n  position(flushChanges = true) {\n    // flushChanges commits the changes immediately, leave true unless you are positioning multiple\n    // tethers (in which case call Tether.Utils.flush yourself when you're done)\n\n    if (!this.enabled) {\n      return;\n    }\n\n    this.clearCache();\n\n    // Turn 'auto' attachments into the appropriate corner or edge\n    const targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n\n    this.updateAttachClasses(this.attachment, targetAttachment);\n\n    const elementPos = this.cache('element-bounds', () => {\n      return getBounds(this.bodyElement, this.element);\n    });\n\n    let { width, height } = elementPos;\n\n    if (width === 0 && height === 0 && !isUndefined(this.lastSize)) {\n      // We cache the height and width to make it possible to position elements that are\n      // getting hidden.\n      ({ width, height } = this.lastSize);\n    } else {\n      this.lastSize = { width, height };\n    }\n\n    const targetPos = this.cache('target-bounds', () => {\n      return this.getTargetBounds();\n    });\n    const targetSize = targetPos;\n\n    // Get an actual px offset from the attachment\n    let offset = offsetToPx(attachmentToOffset(this.attachment), { width, height });\n    let targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n\n    const manualOffset = offsetToPx(this.offset, { width, height });\n    const manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n\n    // Add the manually provided offset\n    offset = addOffset(offset, manualOffset);\n    targetOffset = addOffset(targetOffset, manualTargetOffset);\n\n    // It's now our goal to make (element position + offset) == (target position + target offset)\n    let left = targetPos.left + targetOffset.left - offset.left;\n    let top = targetPos.top + targetOffset.top - offset.top;\n\n    for (let i = 0; i < TetherBase.modules.length; ++i) {\n      const module = TetherBase.modules[i];\n      const ret = module.position.call(this, {\n        left,\n        top,\n        targetAttachment,\n        targetPos,\n        elementPos,\n        offset,\n        targetOffset,\n        manualOffset,\n        manualTargetOffset,\n        scrollbarSize,\n        attachment: this.attachment\n      });\n\n      if (ret === false) {\n        return false;\n      } else if (isUndefined(ret) || !isObject(ret)) {\n        continue;\n      } else {\n        ({ top, left } = ret);\n      }\n    }\n\n    // We describe the position three different ways to give the optimizer\n    // a chance to decide the best possible way to position the element\n    // with the fewest repaints.\n    const next = {\n      // It's position relative to the page (absolute positioning when\n      // the element is a child of the body)\n      page: {\n        top,\n        left\n      },\n\n      // It's position relative to the viewport (fixed positioning)\n      viewport: {\n        top: top - pageYOffset,\n        bottom: pageYOffset - top - height + innerHeight,\n        left: left - pageXOffset,\n        right: pageXOffset - left - width + innerWidth\n      }\n    };\n\n    let doc = this.target.ownerDocument;\n    let win = doc.defaultView;\n\n    let scrollbarSize;\n    if (win.innerHeight > doc.documentElement.clientHeight) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.bottom -= scrollbarSize.height;\n    }\n\n    if (win.innerWidth > doc.documentElement.clientWidth) {\n      scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n      next.viewport.right -= scrollbarSize.width;\n    }\n\n    if (['', 'static'].indexOf(doc.body.style.position) === -1 ||\n      ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {\n      // Absolute positioning in the body will be relative to the page, not the 'initial containing block'\n      next.page.bottom = doc.body.scrollHeight - top - height;\n      next.page.right = doc.body.scrollWidth - left - width;\n    }\n\n    if (!isUndefined(this.options.optimizations) &&\n      this.options.optimizations.moveElement !== false &&\n      isUndefined(this.targetModifier)) {\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n      const offsetPosition = this.cache('target-offsetparent-bounds', () => getBounds(this.bodyElement, offsetParent));\n      const offsetParentStyle = getComputedStyle(offsetParent);\n      const offsetParentSize = offsetPosition;\n\n      const offsetBorder = {};\n      ['Top', 'Left', 'Bottom', 'Right'].forEach((side) => {\n        offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[`border${side}Width`]);\n      });\n\n      offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n      offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n\n      if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {\n        if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {\n          // We're within the visible part of the target's scroll parent\n          const { scrollLeft, scrollTop } = offsetParent;\n\n          // It's position relative to the target's offset parent (absolute positioning when\n          // the element is moved to be a child of the target's offset parent).\n          next.offset = {\n            top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n            left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n          };\n        }\n      }\n    }\n\n    // We could also travel up the DOM and try each containing context, rather than only\n    // looking at the body, but we're gonna get diminishing returns.\n\n    this.move(next);\n\n    this.history.unshift(next);\n\n    if (this.history.length > 3) {\n      this.history.pop();\n    }\n\n    if (flushChanges) {\n      flush();\n    }\n\n    return true;\n  }\n\n  // THE ISSUE\n  move(pos) {\n    if (isUndefined(this.element.parentNode)) {\n      return;\n    }\n\n    const same = {};\n\n    for (let type in pos) {\n      same[type] = {};\n\n      for (let key in pos[type]) {\n        let found = false;\n\n        for (let i = 0; i < this.history.length; ++i) {\n          const point = this.history[i];\n          if (!isUndefined(point[type]) &&\n            !within(point[type][key], pos[type][key])) {\n            found = true;\n            break;\n          }\n\n        }\n\n        if (!found) {\n          same[type][key] = true;\n        }\n      }\n    }\n\n    let css = { top: '', left: '', right: '', bottom: '' };\n\n    const transcribe = (_same, _pos) => {\n      const hasOptimizations = !isUndefined(this.options.optimizations);\n      const gpu = hasOptimizations ? this.options.optimizations.gpu : null;\n      if (gpu !== false) {\n        let yPos, xPos;\n        if (_same.top) {\n          css.top = 0;\n          yPos = _pos.top;\n        } else {\n          css.bottom = 0;\n          yPos = -_pos.bottom;\n        }\n\n        if (_same.left) {\n          css.left = 0;\n          xPos = _pos.left;\n        } else {\n          css.right = 0;\n          xPos = -_pos.right;\n        }\n\n        if (isNumber(window.devicePixelRatio) && devicePixelRatio % 1 === 0) {\n          xPos = Math.round(xPos * devicePixelRatio) / devicePixelRatio;\n          yPos = Math.round(yPos * devicePixelRatio) / devicePixelRatio;\n        }\n\n        css[transformKey] = `translateX(${xPos}px) translateY(${yPos}px)`;\n\n        if (transformKey !== 'msTransform') {\n          // The Z transform will keep this in the GPU (faster, and prevents artifacts),\n          // but IE9 doesn't support 3d transforms and will choke.\n          css[transformKey] += ' translateZ(0)';\n        }\n\n      } else {\n        if (_same.top) {\n          css.top = `${_pos.top}px`;\n        } else {\n          css.bottom = `${_pos.bottom}px`;\n        }\n\n        if (_same.left) {\n          css.left = `${_pos.left}px`;\n        } else {\n          css.right = `${_pos.right}px`;\n        }\n      }\n    };\n\n    const hasOptimizations = !isUndefined(this.options.optimizations);\n    let allowPositionFixed = true;\n\n    if (hasOptimizations && this.options.optimizations.allowPositionFixed === false) {\n      allowPositionFixed = false;\n    }\n\n    let moved = false;\n    if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n      css.position = 'absolute';\n      transcribe(same.page, pos.page);\n\n    } else if (allowPositionFixed && (same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n      css.position = 'fixed';\n      transcribe(same.viewport, pos.viewport);\n    } else if (!isUndefined(same.offset) && same.offset.top && same.offset.left) {\n      css.position = 'absolute';\n      const offsetParent = this.cache('target-offsetparent', () => getOffsetParent(this.target));\n\n      if (getOffsetParent(this.element) !== offsetParent) {\n        defer(() => {\n          this.element.parentNode.removeChild(this.element);\n          offsetParent.appendChild(this.element);\n        });\n      }\n\n      transcribe(same.offset, pos.offset);\n      moved = true;\n\n    } else {\n      css.position = 'absolute';\n      transcribe({ top: true, left: true }, pos.page);\n    }\n\n    if (!moved) {\n      if (this.options.bodyElement) {\n        if (this.element.parentNode !== this.options.bodyElement) {\n          this.options.bodyElement.appendChild(this.element);\n        }\n      } else {\n        let offsetParentIsBody = true;\n\n        let currentNode = this.element.parentNode;\n        while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY' && !isFullscreenElement(currentNode)) {\n          if (getComputedStyle(currentNode).position !== 'static') {\n            offsetParentIsBody = false;\n            break;\n          }\n\n          currentNode = currentNode.parentNode;\n        }\n\n        if (!offsetParentIsBody) {\n          this.element.parentNode.removeChild(this.element);\n          this.element.ownerDocument.body.appendChild(this.element);\n        }\n      }\n    }\n\n    // Any css change will trigger a repaint, so let's avoid one if nothing changed\n    const writeCSS = {};\n    let write = false;\n    for (let key in css) {\n      let val = css[key];\n      let elVal = this.element.style[key];\n\n      if (elVal !== val) {\n        write = true;\n        writeCSS[key] = val;\n      }\n    }\n\n    if (write) {\n      defer(() => {\n        extend(this.element.style, writeCSS);\n        this.trigger('repositioned');\n      });\n    }\n  }\n\n  _addClasses() {\n    const { classes, classPrefix } = this.options;\n    addClass(this.element, getClass('element', classes, classPrefix));\n    if (!(this.options.addTargetClasses === false)) {\n      addClass(this.target, getClass('target', classes, classPrefix));\n    }\n  }\n\n  _removeClasses() {\n    const { classes, classPrefix } = this.options;\n    removeClass(this.element, getClass('element', classes, classPrefix));\n    if (!(this.options.addTargetClasses === false)) {\n      removeClass(this.target, getClass('target', classes, classPrefix));\n    }\n\n    this.all.forEach((className) => {\n      this.element.classList.remove(className);\n      this.target.classList.remove(className);\n    });\n  }\n}\n\nTetherClass.modules = [];\n\nTetherBase.position = position;\n\nlet Tether = extend(TetherClass, TetherBase);\n\nTether.modules.push({\n  initialize() {\n    const { classes, classPrefix } = this.options;\n    this.markers = {};\n\n    ['target', 'element'].forEach((type) => {\n      const el = document.createElement('div');\n      el.className = getClass(`${type}-marker`, classes, classPrefix);\n\n      const dot = document.createElement('div');\n      dot.className = getClass('marker-dot', classes, classPrefix);\n      el.appendChild(dot);\n\n      this[type].appendChild(el);\n\n      this.markers[type] = { dot, el };\n    });\n  },\n\n  position({ manualOffset, manualTargetOffset }) {\n    const offsets = {\n      element: manualOffset,\n      target: manualTargetOffset\n    };\n\n    for (let type in offsets) {\n      const offset = offsets[type];\n      for (let side in offset) {\n        let val = offset[side];\n        if (!isString(val) ||\n          val.indexOf('%') === -1 &&\n          val.indexOf('px') === -1) {\n          val += 'px';\n        }\n\n        if (this.markers[type].dot.style[side] !== val) {\n          this.markers[type].dot.style[side] = val;\n        }\n      }\n    }\n\n    return true;\n  }\n});\n\nexport default Tether;\n"],"names":["isString","value","isUndefined","undefined","addClass","el","name","split","forEach","cls","trim","classList","add","getClass","key","classes","classPrefix","removeClass","remove","updateClasses","all","indexOf","contains","deferred","defer","fn","push","flush","pop","_scrollBarSize","extend","out","args","Array","prototype","apply","arguments","slice","obj","hasOwnProperty","call","getScrollBarSize","inner","document","createElement","style","width","height","outer","position","top","left","pointerEvents","visibility","overflow","appendChild","body","widthContained","offsetWidth","widthScroll","clientWidth","removeChild","id","uniqueId","zeroPosCache","zeroElement","getBounds","doc","documentElement","ownerDocument","docEl","box","_getActualBoundingClientRect","origin","node","setAttribute","getAttribute","_getOrigin","scrollWidth","right","scrollHeight","bottom","clientTop","clientLeft","clientHeight","boundingRect","getBoundingClientRect","rect","k","frameElement","defaultView","frameRect","err","this","cache","_this","element","targetPos","getTargetBounds","abutted","side","targetPosSide","options","length","addTargetClasses","target","BOUNDS_FORMAT","targetAttachment","constraints","bodyElement","lastSize","targetSize","targetHeight","targetWidth","allClasses","constraint","outOfBoundsClass","pinnedClass","_getAllClasses","addClasses","tAttachment","eAttachment","attachment","changeAttachX","changeAttachY","to","pin","bounds","tether","scrollParents","pageXOffset","pageYOffset","innerWidth","innerHeight","nodeType","size","pos","getComputedStyle","win","i","toUpperCase","substr","parseFloat","getBoundingRect","_flipYTogether","_flipXTogether","map","p","pinned","oob","_calculateOOBAndPinnedLeft","_calculateOOBAndPinnedTop","oobClass","_addOutOfBoundsClass","updateAttachClasses","trigger","shift","shiftTop","shiftLeft","Evented","on","event","handler","ctx","once","bindings","off","binding","index","splice","context","_this2","MIRROR_LR","center","MIRROR_TB","middle","OFFSET_MAP","addOffset","offsets","attachmentToOffset","offsetToPx","offset","parseTopLeft","getOffsetParent","offsetParent","TetherBase","modules","Constraint","Abutment","Shift","lastCall","lastDuration","pendingTimeout","tick","transformKey","transforms","tethers","now","performance","Math","min","setTimeout","clearTimeout","window","addEventListener","TetherClass","bind","history","setOptions","module","initialize","defaults","targetOffset","targetModifier","querySelector","Error","jquery","_addClasses","disable","parents","parent","parentNode","overflowX","overflowY","test","getScrollParents","enabled","enable","getVisibleBounds","targetScrollTop","scrollTop","targetIsBody","scrollBottom","borderTopWidth","borderBottomWidth","borderLeftWidth","fitAdj","pow","max","scrollPercentage","getScrollHandleBounds","clearCache","_cache","getter","_this3","removeEventListener","_this4","destroy","_removeClasses","_this5","elementAttach","targetAttach","_addAttachClasses","_this6","flushChanges","relativeToAttachment","autoToFixedAttachment","elementPos","_this7","manualOffset","manualTargetOffset","ret","scrollbarSize","next","page","viewport","parentElement","optimizations","moveElement","offsetPosition","offsetParentStyle","offsetParentSize","offsetBorder","toLowerCase","scrollLeft","move","unshift","a","b","diff","same","type","found","point","within","css","transcribe","_same","_pos","yPos","xPos","_this8","gpu","devicePixelRatio","round","allowPositionFixed","e","d","moved","offsetParentIsBody","currentNode","tagName","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","writeCSS","write","val","className","_this9","Tether","markers","dot","_this10"],"mappings":"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"}